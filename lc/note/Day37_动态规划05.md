# 动态规划05

## 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

拿下面数据举例子：

背包最大重量为4，物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

**每件商品都有无限个！**

问背包能背的物品最大价值是多少？

动规五部曲分析完全背包，为了从原理上讲清楚，我们先从二维dp数组分析：

1. **确定`dp`数组以及下标的含义:**

   `dp[i][j]`表示下标为`[0-i]`的物品，每个物品可以取无限次，放进容量为`j`的背包，价值总和最大是多少

2. **确定递推公式：**

   - **不放物品i**：背包容量为`j`，里面不放物品i的最大价值是`dp[i - 1][j]`。
   - **放物品i**：背包空出物品`i`的容量后，背包容量为`j - weight[i]`，``dp[i][j - weight[i]] `为背包容量为`j - weight[i]`且不放物品`i`的最大价值，那么`dp[i][j - weight[i]] + value[i] `（物品`i`的价值），就是背包放物品`i`得到的最大价值

   递推公式： `dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);`

   （注意，完全背包二维`dp`数组 和 01背包二维`dp`数组 递推公式的区别，01背包中是 `dp[i - 1][j - weight[i]] + value[i])`）

3. **dp数组如何初始化:**

   **关于初始化，一定要和`dp`数组的定义吻合，否则到递推公式的时候就会越来越乱**。

   首先从`dp[i][j]`的定义出发，如果背包容量`j`为`0`的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为`0`。

   `dp[0][j]`，即：存放编号`0`的物品的时候，各个容量的背包所能存放的最大价值。

   那么很明显当 `j < weight[0]`的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。

   当`j >= weight[0]`时，**`dp[0][j] `如果能放下`weight[0]`的话，就一直装，每一种物品有无限个**。

​	代码初始化如下：

```cpp
for (int i = 1; i < weight.size(); i++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[i][0] = 0;
}

// 正序遍历，如果能放下就一直装物品0
for (int j = weight[0]; j <= bagWeight; j++)
    dp[0][j] = dp[0][j - weight[0]] + value[0];
```

4. **确定遍历顺序:**

​	对于二维dp数组来说，递推公式所需要的值，二维dp数组里对应的位置都有。所以两者均可

5. **举例推导dp数组**

### 代码示例

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, bagWeight;
    int w, v;
    cin >> n >> bagWeight;
    vector<int> weight(n);
    vector<int> value(n);
    for (int i = 0; i < n; i++) {
        cin >> weight[i] >> value[i];
    }

    vector<vector<int>> dp(n, vector<int>(bagWeight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagWeight; j++)
        dp[0][j] = dp[0][j - weight[0]] + value[0];

    for (int i = 1; i < n; i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
        }
    }

    cout << dp[n - 1][bagWeight] << endl;

    return 0;
}
```

## 518.零钱兑换II

[力扣题目链接](https://leetcode.cn/problems/coin-change-ii/)

### 题目

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```

 

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同**
- `0 <= amount <= 5000`

### 题解

1. **确定dp数组以及下标的含义**

`dp[j]`：凑成总金额j的货币组合数为`dp[j]`

2. **确定递推公式**

通过思考和举例，可以得到二维dp递推公式： `dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]]`

压缩成一维：`dp[j] += dp[j - coins[i]]`

3. **dp数组如何初始化**

- 其他位置默认为0，但是由于要叠加起来，也就是在刚好能放下的时候加一种方法，所以要把为0的适合设为1

4. **确定遍历顺序**

- 显然需要从左到右

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        vector<uint64_t> dp(amount+1,0);//这个sb地方超出了，所以要扩大一下，而且longlong还不够得uint64_t        
        dp[0] = 1;
        for(int i = 0;i < n;i++ ){
            for(int j = coins[i];j < amount+1;j++){//从这里开始就不用判断力
                dp[j] = dp[j] + dp[j-coins[i]] ;
            }
        }
        return dp[amount];
    }
};
```

## 377. 组合总和 Ⅳ

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`